\section{Persistenzschichten in Java} 	\label{sec:tech-Persistenzschichten}
		
\subsection{Java Data Objects} 
		
JDO wurde im Rahmen eines von Sun initiierten JCR entwickelt. Neben Sun beteiligten sich zahlreiche weitere Firmen an der Entwicklung der Spezifikation, darunter Ericcson, IBM, Informix, Oracle, Poet, Rational, SAP, Software AG und Versant. Der Spezifikationsprozess begann Mitte 1999 und im April 2002 wurde der "`Final Release"' der Spezifikation veröffentlicht, wobei die gesammelten Erfahrungen aller beteiligten Firmen mit objektorientierten Datenbanken eingeflossen sind.\\
Die JDO-Spezifikation gibt verschiedene APIs (Application Programming Interface)
und ebenso Richtlinien zu Ihrer Implementierung als sogenannte Contracts vor. SUN selbst
stellt nur eine Referenzimplementation bereit. Auf dem Markt existieren aber viele
weitere Implementationen.\\
JDO kann sehr unterschiedliche (Speicher-) Technologien verwenden. Applikationen mit JDO sollen portabel über verschiedene Implementationen wie auch über verschiedene Speichertechnologien sein. Hierunter fallen insbesondere relationale und objektorientierte Datenbanksysteme, aber auch Dateisysteme, XML und andere. JDO kann sowohl mit Applikationsservern (Application Server) als auch innerhalb gewöhnlicher (standalone) Java Applikationen eingesetzt werden. Welche Speichertechnologien aber tatsächlich unterstützt werden, ist implementationsabhängig und kann sehr unterschiedlich sein. (siehe \vref{fig:architecture_jdo})

\begin{figure}[h]
	\centering
	%\includegraphics[scale=1]{images/Architektur-JDO.jpg}
	\includegraphics[scale=1]{images/Architektur-JSF.jpg}
	\caption{Architektur von JSF \citep[Bild 2.0]{JDO2003}}
	\label{fig:architecture_jdo}
\end{figure}

Im folgenden werden die nach \citep{Stadtherr2003} wichtigsten Eigenschaften von JDO genannt:

\begin{enumerate}

\item Unabhängigkeit von der JDO-Implementierung: Eine für JDO vorbereitete Applikation kann mit einer beliebigen JDO-Implementierung betrieben werden.

\item Unabhängigkeit vom Datenspeicher: Die API von JDO abstrahiert vollständig von
dem dahinter liegenden Datenspeicher. Dabei kann es sich um eine flache Datei, eine
objektorientierte Datenbank oder eine relationale Datenbank handeln.

\item Transparente und transitive Persistenz: Transparente Persistenz bedeutet, dass diese nicht im Quellcode sichtbar ist. Wenn z.B. mit setX das Attribut X einer persistenten Instanz verändern und anschließend die Transaktion beende wird, dann soll das geänderte Attribut automatisch in die Datenbank geschrieben werden. Aufgrund transitiver Persistenz wird ein Objekt auch dann persistent, wenn es bei Transaktionsende über einen Pfad von Referenzen von einem bereits persistenten Objekt aus erreichbar ist.

\item Klassen-Enhancement: Die JDO-Persistenzschicht einer Applikation wird durch eine
automatische Instrumentierung der Java-Klassen erzeugt. Diese Instrumentierung
wird im Englischen Enhancing genannt. Die automatische Instrumentierung der
Klassen ist der Schlüssel für transparente und transitive Persistenz, da auf diese Art
die notwendigen Mechanismen vor dem Programmierer versteckt werden können.

\item XML-Metadaten: Die persistenten Klassen müssen in einer XML-Datei beschrieben werden. Im einfachsten Fall besteht die Datei nur aus den Namen der persistenten Klassen. Wenn Arrays, Collections oder Maps verwendet werden sollen, müssen dazu auch einige wichtige Informationen (z.B. der Typ in der Collection) in dieser Beschreibungsdatei eingetragen werden.

\item JDO Query Language: JDOQL ist eine Querysprache, die eng an die Syntax von
Java angelehnt ist. Sie ist nicht so mächtig wie SQL, bietet aber die wichtigsten Elemente
einer Datenbank-Querysprache.

\item J2EE Integration: Die JDO-Spezifikation sieht es vor, kompatibel zu den existierenden J2EE-Frameworks zu sein. JDO ist dabei unabhängig von den EJB-Konzepten für Container Managed Persistence und Bean Managed Persistence.

\end{enumerate}

\textbf{Fazit:} Da in der Projektplanungsphase die damalige Version von JDO nur eine eingeschränkte Abfragesprache und eine mangelnde Standardisierung für die Anbindung relationaler
Datenbanksysteme besaß, was für das Projekt als Nachteil anzusehen war, wurde nach anderen Möglichkeiten der Persistierung gesucht. Hierbei erschien Hibernate als die umfassendste Lösung.

\newpage


\subsection{Hibernate}
		
Hibernate ist ein Open Source-Persistenz-Tool, das basierend auf so genannten Mappings das Bindeglied zwischen JavaBeans und einer Datenbank darstellt. Seit September 2003 gehört das Hibernate-Projekt zur JBoss Group und liegt in der aktuellen Version 3.0 kostenlos zum Download\footnote{\url{http://www.hibernate.org}} bereit. Zur Zeit werden 16 Datenbanken unterstützt, worunter unter anderem Oracle, DB2, MySQL sowie PostgreSQL zählen. Zu den weiteren Besonderheiten zählen die Hibernate Query Language, Native SQL Queries sowie Lazy- und Outer-Join Fetching zur Steigerung der Performance. Ferner lässt sich Hibernate problemlos in alle bekannten J2EE Application Server integrieren.\\
Hibernate stellt den Entwicklern ein umfangreiches Werkzeug für die Realisierung einer leistungsfähigen Persistenzschicht zur Verfügung. Hierbei werden grundlegende Mechanismen für das Laden, Speichern, Aktualisieren und Löschen von Java-Objekten, sowie deren Beziehungen, bereitgestellt.\\
Das Abbilden von Java-Objekten auf eine entsprechende Datenbank erfolgt auf einem äußerst flexiblen Weg, da sich diese Java-Klassen und die entsprechenden Konfigurationsdateien sehr einfach aus einem bestehenden Datenbankschema generieren lassen. Auch der umgekehrte Weg (Top-Down), d.h. die Generierung eines Datenbankschemas aus bestehenden Java-Klassen, lässt sich einfach realisieren.

\begin{figure}[h]
	\centering
	%\includegraphics[scale=1]{images/Architektur-Hibernate.jpg}
	\includegraphics[scale=1]{images/Architektur-JSF.jpg}
	\caption{Architektur von Hibernate \citep[Bild 2.1]{Bauer2004}}
	\label{fig:architecture_hibernate}
\end{figure}

\vref{fig:architecture_hibernate} stellt die Rollen der wichtigsten Schnittstellen der Business- und Persistenzschicht von Hibernate dar. Dabei agiert die Businessschicht als ein Client der Persistenzschicht. In manchen Anwendungen werden diese beiden Schichten aber auch nicht getrennt dargestellt. Hibernate ermöglicht nach \citep{Bauer2004} auch die Verwendung von bestehenden Java APIs, wie z.B. JDBC, JTA oder JNDI. JDBC bietet abstrakte Funktionalitäten analog zu relationalen Datenbanken und erlaubt es, fast jede Datenbank über einen JDBC Treiber mit Hibernate verwenden zu können. JNDI und JTA ermöglichen Hibernate die Integration in J2EE Applikationsservern.\\

Über XML-basierte Mapping-Dateien wird das objektrelationale Abbilden der Java-klassen für Hibernate-Anwendungen definiert. Eine solche Mapping-Datei wird mit dem Dateinamen-Suffix \textit{.hbm.xml} versehen und wird generell für jede persistente Klasse erzeugt. In \vref{code:mapping_hibernate} wird das Prinzip der Mapping-Dateien dargestellt.

\begin{lstlisting}[language=XML, caption={Mapping-Datei von Hibernate}, label=code:mapping_hibernate, showstringspaces=false]
<hibernate-mapping>
  <class name="de.hsharz.provirent.objects.Bill" table="BILL">
	
    <id name="billId" type="int" column="BILLID">
      <meta attribute="scope-set">public</meta>
      <meta attribute="use-in-equals">true</meta>
      <generator class="native"/>
    </id>

    <many-to-one name="customer" class="de.hsharz.provirent.objects.Customer">
      <meta attribute="use-in-tostring">true</meta>
    </many-to-one>

    <property name="pdfFile" type="binary">
      <column name="pdffile" sql-type="BLOB" />
    </property>
				
    <property name="pdfFileSize" type="int">
      <meta attribute="use-in-tostring">true</meta>      	
    </property> 

  </class>
</hibernate-mapping>
\end{lstlisting}

In den Mapping-Dateien wird die Zuordnung der einzelnen Attribute (Properties) zu den entsprechenden Tabellenspalten der zugrunde liegenden Datenbank und auch Beziehungen zu anderen persistenten Java-Klassen (Relationen) festgelegt. Die folgende XML-Elemente sollten dabei verwendet werden:

\begin{itemize}

 \item class: Name der Java-Klasse und deren Zuordnung zur korrespondierenden Tabelle der Datenbank
 \item id: Attribut(e) der Klasse für den Primärschlüssel
 \item property: Zuordnung der einzelnen Spalten der Datenbanktabelle zu den Properties der Java-Klasse mit zusätzlichen Angaben über den zu mappenden Datentyp und das Erlauben von Null-Werten
 \item many-to-one: Darstellung einer n:1 Beziehung mit Zuordnung der Spalte aus der Datenbanktabelle zu einer entsprechenden Property und Angabe des Objekttyps der Beziehung

\end{itemize}

Außer diesen gibt es noch weitere Attribute. Über deren Bedeutung informieren die Hibernate-Webseiten.\\
Standardmäßig wird Hibernate über ein zentrales XML-Dokument konfiguriert. Der Name dieser Datei wird meist mit der Endung .cfg.xml gebildet. Darin werden solche Konfigurationen wie Deklaration der Datenbankverbindung, des Hibernate-Dialektes (abhängig vom verwendeten DBMS), sowie zusätzlichen Optionen festgelegt. Ferner können auch die Ressourcen der einzelnen Mapping-Dateien angegeben werden, um diese der Java-Applikation bekanntzumachen.\\
Vor der Verwendung von Hibernate als Persistenzmechanismus in einer Anwendung muss die Hibernate-Umgebung initialisiert werden. Hierbei wird die Klasse \textit{SessionFactory} in der Geschäftslogik der Anwendung geladen. Mit Hilfe dieser Klasse lässt sich eine Session-Instanz erzeugen, die als ein Bindeglied zwischen der Datenbank und der Anwendung fungiert. Nur über diese Session ist die Interaktion mit den Datenbankobjekten möglich. Darunter sind die so genannten "`CRUD-Methoden"' (create, retrieve, update, delete) oder Queries (Abfragen mit HQL\footnote{Hibernate Query Language}) zu verstehen. \vref{code:save_hibernate} illustriert das Speichern des persistenten Objekts \textit{Dvd} in die Datenbank.\\

\begin{lstlisting}[language=Java, caption={Save-Methode der Hibernate-API}, label=code:save_hibernate, showstringspaces=false]
try {
  Dvd dvd = (Dvd) session.save(new Dvd());
} catch (HibernateException e) {
  logger.error("Objekt konnte nicht gespeichert werden", e);
}
\end{lstlisting}

Hibernate besitzt auch eine Transaktionsschnittstelle. So lassen sich über eine Transaktions-Instanz, die über das Session-Objekt erzeugt werden kann, Transaktionen durch geeignete Methoden (\textit{begin}/\textit{commit}/\textit{rollback}) abgrenzen. Diese Schnittstelle ist insofern erweiterbar, dass sie leicht mit anderen Systemen integriert werden kann. Weiterhin stehen dem Entwickler als Transaktionsstrategien sowohl optimistisches als auch pessimistisches Locking  zur Verfügung.\\
Ein weiteres Merkmal von Hibernate ist die Möglichkeit der automatischen Generierung von Primärschlüsseln, wobei an die 10 verschiedenen Möglichkeiten, wie z.B. Sequenzen, im Vordergrund stehen.\\
Darüber hinaus stellt Hibernate verschiedene Abfragesprachen zur Verfügung. Hierbei sind die Hibernate Query Language (HQL), Query By Criteria und Query By Example zu nennen. HQL ist an SQL angelehnt, beherrscht aber auch objektorientierte Konzepte wie Vererbung und Assoziationen. Die Anfragen werden dabei in Zeichenketten abgelegt und Hibernate übergeben. Dieses Konzept lässt sich in den Referenz-Dokumenten\footnote{siehe \citep{Hibernate2005}} von Hibernate  genauer betrachten. Bei der Verwendung von Query By Criteria werden keine Zeichenketten benutzt, sondern eine Anfrage setzt sich aus einzelnen Ausdrücken zusammen, die zu einer so genannten \textit{CriteriaQuery} hinzugefügt werden. Demnach wird die Syntax der Abfragen bereits zur Übersetzungszeit durch den Compiler und nicht erst zur Laufzeit überprüft. Die Query By Example Schnittstelle nutzt das Konzept von Query By Criteria. Hierbei wird eine mit entsprechenden Suchdaten versehene Beispielklasse einer \textit{CriteriaQuery} übergeben, woraufhin diese alle Klassen zurückliefert, die den Eigenschaften der übergebenen Klasse entsprechen.

























%Hier danach nicht mehr schreiben
\label{sec:tech-Persistenzschichten-ende}