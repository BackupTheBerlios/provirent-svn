\section{Java-Web-Anwendungen} \label{sec:tech-WebAnwendungen}
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Kapitel JSF           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
\subsection{Java Server Faces - JSF}
		
Nach \citep{Bill2004} ist JavaServer Faces (JSF) ein komponenten-abhängiges Web-Framework, mit dessen Hilfe sich Benutzerschnittstellen mit einer Reihe von wiederverwendbaren GUI-Komponenten, z.B. Labels, Buttons, Eingabefelder usw.,einfach erstellen lassen. JSF ist ein erster offizieller Standard von Sun hinsichtlich der Erstellung von UIs\footnote{User Interface (engl. Benutzerschnittstelle)} von Webanwendungen und wurde im Rahmen des Java Community Process (JCP) unter dem JSR 127\footnote{\url{http://www.jcp.org/en/jsr/detail?id=127}} im September 2002 veröffentlicht. Im Experten-Gremium sind viele namhafte Firmen wie IBM, BEA, IONA, Novell, Borland, HP, Oracle oder Siemens, wodurch eine große Unterstützung seitens der Industrie erwartet wird.

\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{images/Architektur-JSF.jpg}
	\caption{Architektur von JSF \citep[Bild 1.6]{Bill2004}}
	\label{fig:architecture_jsf}
\end{figure}

Die auf dem bekannten Model View Controller 2(MVC2)-Modell basierende JSF-Technologie besteht aus den folgenden zwei Hauptkomponenten:

\begin{itemize}
	\item JSF API
	\item JSF Tag Libraries
\end{itemize}

Das Präsentations-Framework JSF muss die von MVC definierten Komponenten abbilden. Wie in \vref{fig:architecture_jsf} zu sehen ist, wird das Modell durch einfache JavaBeans, aber auch durch EJBs\footnote{Enterprise Java Beans} oder JDOs\footnote{Java Data Objects} abgebildet. Der Controller wird durch Action Handler bzw. Event Listener der jeweiligen UI-Komponenten dargestellt. Im Zentrum des Controllers steht das FacesServlet, welches mit Hilfe der Konfiguration reagieren, agieren und navigieren kann. JSPs und Komponenten sowie deren Renderer, Converter und Validatoren bilden die Views ab. In jeder View, welche meistens durch eine JavaServer Page (JSP) aufgebaut ist, existiert ein entsprechender Component Tree. Dieser beinhaltet alle Komponenten, die in der JSP durch definierte Tags dargestellt werden. Somit hat der Entwickler Zugriff auf alle Komponenten im Laufe des Lebenszyklus der Request-Bearbeitung.

Dieser Lebenszyklus wird zu jeder Anfrage an die JSF-Applikation durchlaufen und enthält folgende Phasen:
 
\begin{enumerate}
	\item Restore View: Aufbau des Component Tree
	\item Apply Request Values: Die Daten aus dem Request werden den Komponenten zugeordnet
	\item Process Validations: Die Variablen der Komponenten werden validiert
	\item Update Model Values: Die Variablen der Komponenten werden in deren Datenmodellen gespeichert
	\item Invoke Application: Ausführung der Business-Logik
	\item Render Response: Der Component Tree wird aktualisiert und ein Response generiert
\end{enumerate}		

Die Navigation in einer JSF-Applikation wird in einer Konfigurationsdatei definiert. Darin ist für jede JSP jeweils eine Navigationsregel festgelegt. Diese Regeln bestehen aus der Aufrufenden Seite sowie verschiedenen Navigationsfällen. Solche Fallunterscheidungen machen die Navigation abhängig von den Ergebnissen der Businesslogik und sorgen für die Dynamik der Anwendung. (vgl. \citep[S.~46ff]{Oeztuerk2004})\\

\textbf{Fazit:} Da in der Projektplanungsphase die derzeitige JSF-Spezifikation zwar relativ ausgereift war, aber noch nicht in einer Finalversion vorlag, wurde in der Phase der Implementierung auf dessen Verwendung verzichtet und stattdessen auf Apache Struts zurückgegriffen.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Kapitel Struts        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Apache Struts}

Struts basiert auf dem Model 2 (MVC 2) und ist ein leistungsstarkes und frei erhältliches Framework. Hierbei wird die Präsentationsebene durch JavaServer Pages konstruiert, der Model-Teil durch JavaBeans übernommen und Servlets als Controller dieses Frameworks eingesetzt.
Das Struts Framework Projekt wurde nach \citep{ASF2005} im Mai 2000 von Craig R. McCalahan ins Leben gerufen und versuchte die Vorteile von Java Servlets und JavaServer Pages zu vereinen. Zu Beginn wurde ein Model-View-Controller Framework für die Java-Welt erarbeitet, welches im Juli 2001 von der Apache Software Foundation (ASF) unter dem Namen Struts 1.0 veröffentlicht wurde.  Die ASF ist eine ehrenamtlich arbeitende Organisation zur Förderung der Apache-Softwareprojekte. Sie entstand im Juni 1999 aus der Apache Group und soll den Apache Open-Source-Software Projekten organisatorische, juristische und finan-zielle Unterstützung zur Verfügung stellen. Die ASF ist eine nicht kommerzielle Organisation aus Entwicklern, die an Open-Source-Softwareprojekten arbeiten. Auch Struts ist ein Open-Source Projekt und unterliegt der Apache Software License\footnote{\url{http://www.apache.org/licenses/}}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{images/Architektur-Struts.jpg}
	\caption{Architektur von Struts \citep[Bild 1.5]{Bill2004}}
	\label{fig:architecture_struts}
\end{figure}

\newpage

Wie bereits erwähnt, verfolgt Struts das Model2-Konzept und lässt sich somit in die drei Komponenten (Model, View und Controller) unterteilen. \vref{fig:architecture_struts} gibt einen Überblick der Architektur von Struts, welche diese Komponenten vereint. Diese einzelnen Komponenten werden in den folgenden Abschnitten detailliert beschrieben.

\subsubsection*{Die Strutskomponente Model}

Das Model von Struts wird durch JavaBeans implementiert. Je nach Funktionalität
können sie in drei Kategorien unterteilt werden:

\begin{itemize}
	\item Beans für den Systemzustand
	\item Beans für die Anwendungslogik
	\item ActionForm-Beans
\end{itemize}

Die Beans für den Systemzustand repräsentieren die Zustandsinformationen des Systems über
deren Attribute. Der interne Zustand der Anwendung wird somit durch eine oder mehrere Beans und den Attributen dargestellt. Im Beispiel der Provirent-Anwendung lässt sich der Einkaufskorb durch ein Bean darstellen, da es beinhaltet, was ein Kunde für seine Bestellung ausgewählt hat. Zur Darstellung des aktuellen Zustands können die zugehörigen "`get"'- und "`set"'-Methoden aufgerufen werden. Zum Beispiel kann die Anzahl der ausgewählten Artikel, die durch das Attribut anzahlArtikel dargestellt wird, über den Aufruf der Methode getArtikelAnzahl() abgefragt werden.

Die Anwendungslogik kann durch JavaBeans ergänzt werden. Damit eine Wiederverwendung der Anwendungslogik gewährleistet werden kann, sollten die JavaBeans möglichst so implementiert werden, dass sie unabhängig von der Umgebung der Anwendung ausgeführt werden können. Zum Beispiel sollte die Logik zum Speichern von Bestellungen in die Datenbank ausgelagert werden. Hierbei müssen die Funktionalitäten für den Zugriff auf die Datenbank korrekt implementiert werden. Diese Methoden der JavaBeans können dann sowohl in der Struts-Applikation als auch in anderen Umgebungen, wo Datenbankzugriffe gebraucht werden, aufgerufen werden.

Die ActionForm-Beans dienen zur Behandlung eines Formulars einer Webanwendung. Für jedes Eingabeformular ist ein entsprechendes ActionForm-Bean vorgesehen. Dieses ermöglicht das Zwischenspeichern von Formulareingabedaten, wobei jedes Eingabefeld einem Attribut der Bean entspricht. Mit der Verwendung von ActionForm Beans ist es möglich, auf die Daten des Formulars in verschiedenen Bereichen der Anwendung zuzugreifen. Eine solche Bean ist von der Klasse \textit{ActionForm} abgeleitet und kann neben den "`get"'- und "`set"'-Methoden optional noch zwei spezielle Methoden besitzen: \textit{validate}() und \textit{reset}(). Die Methode validate() dient dazu, Eingabedaten aus dem Formular zu validieren. Die Attribute eines Formulars lassen sich durch die Methode reset() zurücksetzen. Aufgrund der zwingend erforderlichen Namensgleichheit zwischen den Formularelementen und den Attributen der ActionForm Beans wird die Kommunikation zwischen dem Bean und dem HTML-Formular sichergestellt.

\subsubsection*{Die Strutskomponente View}

Die View ist für die Präsentation der Daten zuständig, die meist durch JavaServer Pages umgesetzt wird. Die JSPs können neben HTML, XML und JavaScript, auch zur Laufzeit dynamisch generierten Code enthalten. Da es möglichst vermieden werden sollte, Java-Code in die JSP einzubauen werden so genannte Tags eingesetzt. Die JSP-eigenen Tags werden durch die umfangreichen Struts Tag-Bibliotheken (Taglibs) erweitert, wodurch eine größere Funktionalität erreicht werden kann. Wie in \vref{code:integration_struts_taglibs} zu erkennen ist, wird jeder einzelnen Bibliothek ein Präfix zugeordnet, damit der Compiler diese auseinander halten kann.

\begin{lstlisting}[language=XML, caption={Integration der StrutsTaglibs}, label=code:integration_struts_taglibs, showstringspaces=false]
<\%@ taglib uri="http://struts.apache.org/tags-bean" prefix="bean" \%>
<\%@ taglib uri="http://struts.apache.org/tags-html" prefix="html" \%>
<\%@ taglib uri="http://struts.apache.org/tags-logic" prefix="logic" \%>
<\%@ taglib uri="http://struts.apache.org/tags-tiles" prefix="tiles" \%>
\end{lstlisting}

Neben diesen Bibliotheken lassen sich auch noch eine Reihe anderer Tag-Bibliotheken, wie die Java Standard Tag Library (JSTL), integrieren. Wenn die Funktionalitäten dann immer noch nicht ausreichen sollten, besteht auch die Möglichkeit, eigene Bibliotheken zu erstellen und zu benutzen. Mit der Verwendung solcher Taglibs wird nach \citep{Cavaness2004} für eine deutliche Senkung der Entwicklungszeit und die daraus resultierende Steigerung der Produktivität erreicht. Auch die Fehlerbehandlung und die Kommunikation mit den ActionForm Beans wird dadurch vereinfacht. 

Darüber hinaus ist man in der Lage, die Web-Anwendung in mehreren Sprachen zu unterstützen. Dabei muss die JSP nicht in mehreren Sprachen auf dem Server hinterlegen werden, sondern es können hierfür die vom Struts-Framework bereitgestellten Message-Tags verwendet werden. 

\begin{lstlisting}[language=XML, caption={Struts Message-Tag}, label=code:message_tag, showstringspaces=false]
<title>
  <bean:message key="provirent.title"/>
</title>
\end{lstlisting}

An dem Präfix \textit{bean} in \vref{code:message_tag} ist zu erkennen, dass dieses Tag der \textit{struts-bean.tld} Bibliothek angehört. Das Attribut \textit{key} verweist auf ein Element einer zentral definierten Datei, in der alle Texte einer Sprache enthalten sind. Es handelt sich hierbei um eine Properties-Datei mit Key-Value Paaren, die für jede der unterstützten Sprachen vorliegt. Die Schlüssel werden in den Message-Tags angegeben und verweisen auf die entsprechenden Texte (Values) der jeweiligen Sprache, die in jeder dieser Properties-Dateien enthalten sind. Dies hat den Vorteil, dass keine Texte mehr in den Quellcode der JSP geschrieben werden müssen, sondern durch den Einsatz der Message-Tags in der gewünschten Sprache zu Laufzeit eingefügt werden. Der Name und der Pfad der Properties-Datei sind frei wählbar, müssen aber in der Konfigurationsdatei des Frameworks definiert werden. Es muss darauf geachtet werden, dass eine sprachenabhängige Properties-Datei der Namenskonvention entspricht, d.h. im Format \verb|<name_der_Message_Datei>_xx.properties|, wobei das \textit{xx} für den zweistelligen Code der jeweiligen Länder bzw. Sprachen steht (z.B. \textit{en} für Englisch, d\textit{e} für Deutsch). 

Für die Interaktion von JSPs mit den ActionForm Beans wurden die Standard HTML-Tags in den Struts Taglibs um gewisse Funktionalitäten erweitert. Prinzipiell kommen alle wichtigen HTML-Elemente  darin vor. Zum Beispiel lässt sich mit Hilfe des Tags \verb|<html:form\>| ein HTML-Formular erstellen. Über das Pflichtattribut \textit{action} wird angegeben, wie nach dem Absenden der Formulardaten damit verfahren werden soll. Hierbei kann eine URL angegeben werden. Es ist aber gängiger, keine Web-Ressourcen, sondern eine Action-Klasse aufzurufen, was durch die Endung \textit{*.do} gekennzeichnet wird und dem Controller mitteilt, in der struts-config.xml nach dem entsprechenden Pfad zu suchen. Ein solcher Pfad stellt die Verknüpfung von ActionForm Beans und Action Klassen der JSP dar. Anhand dieser Zuordnungen können die Formulardaten der ActionForm Bean zugewiesen und validiert werden.

Wenn durch die \textit{validate}()-Methode ein Fehler festgestellt wird, kann dem Benutzer eine entsprechende Fehlermeldung über den Tag \verb|<html:errors\>| mitgeteilt werden. Dieser Tag wird nur aktiv, wenn die mit dem Attribut property definierte Fehlermeldung während der Validierung erzeugt wurde.

Zusätzlich zu den oben genannten Tags der Struts-Taglibs stehen dem Struts-Framework noch eine Reihe weiterer Tags zur Verfügung. Es können auch die Taglibraries der JSTL Spezifikation\footnote{\url{http://java.sun.com/products/jsp/jstl/index.jsp}} eingesetzt werden.


\subsubsection*{Die Strutskomponente Controller}

Der gesamte Ablauf einer Struts-Anwendung wird über den zentral im Struts-Framework vorliegenden Controller gesteuert. Dessen Aufgabe ist es, HTTP-Requests vom Client zu empfangen, diese auszuwerten und zu entscheiden, welche Maßnahme als nächstes durchgeführt werden soll. Wenn z.B. kein Verarbeitungsschritt mehr notwendig sein sollte, so wird die Anfrage direkt an die JSP weitergeleitet, ansonsten an die spezifische Action-Klasse. Besonders vorteilhaft ist nach \citep{Cavaness2004} die an einem zentralen Punkt liegende Ablaufsteuerung der Anwendung durch den Controller. Bei daran notwendigen Änderungen muss nicht die ganze Anwendung sondern nur ein relativ kleiner Bereich des Programms angepasst werden.
Der Controller umfasst folgende Komponenten:

\begin{itemize}
	\item die Klasse ActionServlet
	\item die Datei struts-config.xml
	\item die Klasse ActionMapping
	\item verschiedene Klassen, die sich von der Klasse Action ableiten
\end{itemize}

Jede Anwendung enthält genau ein ActionServlet, das alle Requests des Benutzers verarbeitet. Dieses Servlet sucht in der Struts-Konfigurationsdatei nach der Action für den gerade zu bearbeitenden Request. Darüber hinaus erzeugt und verwendet es ActionForm Beans für das Speichern und Validieren von Daten aus HTML-Formularen und ActionForward Klassen für die Fortsetzung des Programmflusses. Das Servlet wird von der Klasse \textit{org.apache.struts.action.ActionServlet} abgeleitet und wird in der Konfigurationsdatei \textit{web.xml} registriert.

Bei einem Request an die Web-Applikation, dessen URL mit *.do endet, schaltet sich das Struts-Framework ein, indem das ActionServlet die Anfrage an die in der URL angegebene Action weiterleitet. Dies geschieht über ActionMappings, welche in der \textit{struts-config.xml} angegeben sind. 

Ein solches Mapping wird für das Abbilden von speziellen Ereignissen auf die zuständigen Action-Klassen benötigt, was in Struts durch Einträge in die XML-Datei realisiert wird. Der Ablauf der Anwendung kann somit sehr einfach verändert werden, da lediglich eine Datei angepasst werden muss. Dadurch wird die Datei struts-config.xml zum tatsächlichen Mittelpunkt des Frameworks. Ein weiterer Vorteil der Zentralisierung der ActionMappings liegt darin, dass der Ablauf einer Applikation besser zu verstehen ist, wenn dieser nicht im Quellcode versteckt ist. In \vref{code:struts_config_auszug} wird eine solche Konfiguration dargestellt.

\begin{lstlisting}[language=XML, caption={Auszug aus struts-config.xml}, label=code:struts_config_auszug, showstringspaces=false]
<struts-config>

  <form-beans>

    <form-bean name="LoginForm" 
    	type="de.hsharz.provirent.customer.form.LoginForm"/>

  </form-beans>

  <global-forwards>

    <forward name="index" path="/index.do"/>
    <forward name="login" path="/Login.do"/>
    <forward name="logout" path="/Logout.do" />

  </global-forwards>

  <action-mappings>

    <action path="/index" forward="provirent.index"/>
		
    <action path="/Login" input="vkb.scharf.admin.login" 
    	type="de.hsharz.provirent.customer.action.LoginAction" name="LoginForm" 
    	validate="true"/>

  </action-mappings>

  <message-resources parameter="MessageResources"/>

</struts-config>
\end{lstlisting}

Im Bereich \verb|<form-beans>| wird die Zuordnung der HTML-Formulare zu den entsprechenden ActionForm Beans vorgenommen. Über das Attribut \textit{name} wird dem ActionForm eine Bezeichnung gegeben, unter der es aufgerufen bzw. initialisiert werden kann, während \textit{type} den vollständigen Namen der zugehörigen Java-Klasse angibt.

Der Abschnitt \verb|<global-forwards>| ist dazu notwendig, logische Namen bestimmten URLs (JSPs oder Actions) zuzuordnen. Der Entwickler hat dann die Möglichkeit, im Quellcode diese Namen mit dem Vorteil anzusprechen, dass Änderungen an den URLs nur noch in der Konfigurationsdatei vorgenommen werden müssen.

Mit \verb|<action-mappings>| wird die Zuordnung bestimmter Request-URLs auf die Action-Klassen definiert. Dabei wird für jedes Ereignis ein eigenes \verb|<action>| Element angelegt. Dessen Attribut \textit{path} gibt die URL der Action an. Nach \vref{code:struts_config_auszug} wird z.B. durch den Aufruf der URL http://localhost:8080/customer/Login.do das ActionMapping \textit{/login} aufgerufen. Über das Attribut \textit{type} wird der vollständige Pfad der Action-Klasse angegeben, während \textit{name} den Namen der zugeordneten ActionForm Bean festlegt. Ein weiteres Attribut \textit{input} gibt die URL einer JSP oder Action an, die für die Auslösung des ActionEvents verantwortlich ist.

Mit dem Element \verb|<forward>| definiert man, ähnlich wie bei den Global Forwards, eine mögliche URL, die nach dem Ausführen der Action-Klasse aufgerufen werden kann. Ein solcher Forward wird einer bestimmten Action zugeordnet, somit kann sie auch nur aus dieser Action-Klasse aufgerufen werden. Der Vorteil der ActionMappings ist, dass man jede beliebige Action-Klasse aufrufen und an jede JSP oder andere Action weiterleiten kann. 

Action-Klassen sind die Schnittstellen zwischen den Benutzeranfragen und der Geschäftslogik. Bei deren Erstellung spielen nach \citep{Goodwill2004} folgende Faktoren eine Rolle:

\begin{itemize}
	\item Sie wird von der Klasse \textit{org.apache.struts.action.Action} abgeleitet.
	\item Sie implementiert die \textit{execute}()-Methode und enthält die spezifische Logik.
	\item Die neue Action muus kompiliert werden und sich danach in dem Verzeichnis der Web-Applikation befinden ( meistens \textit{/WEB-INF/classes} ).
	\item Es muss ein neues \verb|<action>| Element in der Konfiguration erstellt werden, dass die neue Action abbildet.
\end{itemize}

Die \textit{execute}()-Methode einer Action-Klasse wird aufgerufen, sobald diese die Kontrolle erhalten hat. Nach \citep{Goodwill2004} wird daraufhin die benutzerdefinierte Geschäftslogik ausgeführt und die Anfrage weitergereicht. Innerhalb dieser Methode werden alle Operationen, die zum Durchführen des Requests nötig sind, durchgeführt. Nach \citep{Wolff2004} und \citep{Robinson2004} sind das hauptsächlich:

\begin{itemize}
	\item Authentifizierung des Userstatus (Zugriff auf die Session)
	\item Validierung der Formulareingaben
	\item Zugriff auf die Geschäftslogik
	\item Aufbereitung der Ergebnisse aus der Geschäftslogik, so dass diese angezeigt wer-den können, und Aktualisieren der ActionForm
	\item Rückgabe eines ActionForward-Objektes, das die nachfolgende Aktion angibt
\end{itemize}

Bei der Erstellung von Action-Klassen muss darauf geachtet werden, dass diese thread-safe und reentrant (wiedereintrittsfähig) sind. Sie sollten also in einer Multi-Thread Umgebung richtig arbeiten können. Aus diesem Grund sollten nur lokale Variablen und Methoden zum Einsatz kommen. Darüber hinaus kann es zu Skalierungsproblemen kommen, wenn für jeden Benutzer Ressourcen, wie z.B. Datenbank-Verbindungen, erzeugt und verwendet werden. Solche Ressourcen sollten über Pools vergeben werden. 

















%Hier danach nicht mehr schreiben
\label{sec:tech-WebAnwendungen-ende}