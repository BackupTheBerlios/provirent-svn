\section{Versionsverwaltung} \label{sec:tech-Versionsverwaltung}
Eine Versionsverwaltung ist ein System der Softwareentwicklung zur Versionierung und Kontrolle des gemeinsamen Zugriff's auf Quelltexte. Mit Hilfe einer solchen Software werden laufende Änderungen an Quelltexten oder ähnlichen Dateien erfasst und in einem Archiv mit Zeitstempel und Benutzerkennung erfasst. Ein Archiv, auch Repository genannt, ist dabei meist einen Datenbank oder ein systemabhängiges Dateiformat. Mit Hilfe einer Versionsverwaltung können mehrere Benutzer (Entwickler) einem einem Projekt, sogar an einer Datei gleichzeitig arbeiten. Ohne des Einsatz einer Versionsverwaltung ist es sehr schwierig in einem Team eine Software zu entwickeln. Jeder Entwickler muss immer den aktuellen Stand der Quelltexte besitzen und müsste sich mit den anderen Entwickler absprechen, welche Dateien von wem bearbeitet werden, eine gleichzeitige Bearbeitung einer Datei wäre nur mit großem Aufwand möglich, wie in \vref{fig:vv-personen} beispielhaft zu sehen ist. Weiterhin ist es in Fehlerfällen schwierig auf ältere Projektstände zurückzugreifen. Da in der heutigen zeit viele Projekte global, von mehreren Entwicklern weltweit, unter Zeitdruck entwickelt werden, ist der Einsatz einer Versionsverwaltung zwingend notwendig. Eine Versionsverwaltung übernimmt dabei folgende Aufgaben:
\begin{itemize}[itemsep=.5cm]
	\item frühere Versionen reproduzierbar
	\item kontinuierliche Generationsfolge sicherstellen
	\item Platzsparende Speicherung
	\item Schutz vor unberechtigtem Zugriff
	\item Kostenreduzierung
\end{itemize}
\begin{figure}[tbp]
	\centering
	\includegraphics[scale=0.45]{images/vv-personen.jpg}
	\caption{Softwareentwicklungs-Praxis \citep[Bild 2.1]{Herold1995}}
	\label{fig:vv-personen}
\end{figure}
Jeder Entwickler muss eine \emph{Arbeitskopie} des Projektes vom Repository anfordern. Dieser Vorgang wird als \emph{"`Checking out"'} bezeichnet und einmalig am Anfang erfolgen. Danach aktualisiert er seine Arbeitskopie auf den aktuellsten Stand des Repository. Bei der Speicherung (\emph{"`Commit"'}) der neuen Zusände der Quelltexte in dem Repository werden den einzelnen Dateien oder dem aktuellen Projektstand eine aufsteigende Nummer vergeben. Somit weiß der Entwickler, dass der sich gerade in \emph{Revision} 13.2 befindet. Da jede Revision in dem Repository gespeichert wird, ist es dem Entwickler möglich, auf ältere Revisionen zurückzugreifen und somit ältere Dateien betrachten. Dies ist bspw. notwendig um Änderungen nach zu vollziehen bei eventuellen aktuellen Fehlern. Weiterhin müssen wichtige z.Z. nicht nbenötigte Teile des Quelltextes nicht auskommentiert werden, sondern können gelöscht werden. Somit können \emph{frühere Versionen reproduziert} werden. Durch die automatische Vergabe der Revisionsnummern, wird weiterhin die \emph{kontinuerliche Generationsfolge} sichergestellt. Der Entwickler ist gezwungen vor dem Speichern seiner Quelltexte in dem Repository, die aktuelle Revision aus dem Repository zu laden. Denn nur dadurch wird sichergestellt, dass nach der Speicherung der Revision 13.2 die Revision 13.3 folgt. Möchten bspw. zwei Entwickler eine Datei editieren und letztendlich zum Repository hinzufügen, müssen beide vor dem Speichern die aktuellste Version laden. \Vref{fig:kontinuerlicheEntwicklung} veranschaulicht den dargestellten Sachverhalt. Dabei möchten sowohl \emph{EntwicklerA} als auch \emph{EntwicklerB} eine Datei \emph{QuellcodeA.txt} zu bearbeiten. Zum gleichen Zeitpunkt aktualisieren beide ihre lokale Arbeitskopie zur aktuellen Revision \emph{13.2} und beginnen die Datei zu verändern. EntwicklerB ist nach einer kurzen Zeit mit seinen Änderungen fertig und möchte diese im Repository speichern. Diese Aktion wird erfolgreich vom Versionsverwaltungsserver quittiert, indem die Revision 13.3 vergeben wird und somit die aktuelle Revision der Datei \emph{QuellcodeA.txt} ist. EntwicklerB ist mit seiner Arbeit an dieser Datei fertig. Nach einer Weile möchte EntwicklerA seine Änderungen im Repository speichern und versucht dies. Der Versionsverwaltungsserver wird dem EntwicklerA mitteilen, dass seine lokale Kopie mit der Versionsnummer 13.2 nicht mehr die aktuellste ist und zwingt den EntwicklerA zuerst die aktuelle Revision der zu speichernden Datei zu laden. Nachdem der EntwicklerA dies getan hat, muss er eventuelle Konflikte zwischen beiden Dateien beheben und kann danach die Datei im Repository mit der Revisionnummer 13.4 speichern.
\begin{figure}[tbp]
	\centering
	\includegraphics[scale=1.0]{images/kontinuierlicheGenerationsfolge.pdf}
	\caption{Kontinuierliche Entwicklung}
	\label{fig:kontinuerlicheEntwicklung}
\end{figure}
Da im Laufe der Projektzeit viele Änderungen an dem Projekt im Repository gespeichert werden, ist der Speicherplatz enorm. Der Versionsverwaltungsserver speichert jedoch nicht jede Revision komplett in seinem Repository. Die erste Revision einer Datei muss komplett gespeichert werden, für alle darauf folgenden Revisionsstände werden nur die Unterschiede zur Vorgängerversion gespeichert, siehe auch \vref{fig:vvspeicherbedarf}. Der Versionsverwaltungsserver kann aus diesen Informationen jeden Revisionsstand wieder herstellen und bietet somit eine \emph{platzsparende Möglichkeit zur Speicherung} der Revisionen.
\begin{figure}[tbp]
	\centering
	\includegraphics[scale=0.75]{images/vv-speicherbedarf.jpg}
	\caption{Speicherbedarf einer Versionsverwaltung \citep[Bild 2.2]{Herold1995}}
	\label{fig:vvspeicherbedarf}
\end{figure}
Ein Versionsverwaltungsserver bietet über verschiedene Sicherheitsmechanismen \emph{Schutz vor unberechtigtem Zugriff}. Dabei muss sich jeder Entwickler über einen definierten Mechanismus authentisieren, meist anhand eines Benutzernamens mit einem dazugehören Passwort. Dazu werden abgestufte Zugriffsrechte für verschiedene Projektmitglieder auf einzelne Projektteile vergeben, meist anhand der Zuständigkeit der Projektmitglieder. Bei der Speicherung eines neues Versionsstandes im Repository wird immer der Benutzer mit gespeichert, damit ist es möglich, nachzuvollziehen, welcher Benutzer welche Änderungen vorgenommen hat. Ein weitere wichtige Aufgabe einer Versionsverwaltung ist die \emph{Kostenreduzierung}. Durch die bereits erwähnten Aufgaben einer Versionsverwaltung verringert sich der organisatorische Aufwand des Projektes, Fehler werden vermieden und ein weltweit aktives Team kann gleichzeitig an dem Projekt arbeiten \citep{Fogel2002,Herold1995,Rechenberger1994,Wikipedia2005}. \\
Versionsverwaltungen können, wie andere Software Produkte heutzutage auch, in zwei verschiedene Gruppen eingeteilt werden: die kommerziellen Produkte und die Open-Source Produkte. Bei der kommerziellen Versionsverwaltungssystemen gibt es bspw. Microsoft's Visual SourceSafe\footnote{\url{http://msdn.microsoft.com/ssafe}} oder Borland's Starteam\footnote{\url{http://www.borland.com/starteam/}}. In den folgenden zwei Unterabschnitten werden zwei bekannte  Open Source Versionsverwaltungen beschrieben.




%====================================
\subsection{Concurrent Versions System - CVS}
Bei CVS handelt es sich um eine Versionsverwaltung mit einer Client-Server Architektur. Die Entwicklung von CSV begann mit Ansammlung von Shell-Skripten, die in einer Newsgroup 1986 von Dick Grune veröffentlicht wurden. Im Jahre 1989 begann Brian Berliner mit späterer Hilfe von Jeff Polk mit der eigentlichen Entwicklung von CVS. Das Concurrent Versions System ist ein Kommandozeilen orientiertes System, auf das mit Hilfe verschiedener Client-Interfaces zugegriffen werden kann. Im Laufe der zeit hat sich CVS zu \emph{der} Versionsverwaltung von Open-Source Projekten entwickelt und wird bspw. von sourceforge.net eingesetzt. Innerhalb des Archiv/Repository existieren mehrerer \emph{Module}, die eine Sammlung von Dateien sind und dabei meist ein einzelnes Projekt darstellen. Dadurch, dass jede Datei eine eigene fortlaufende Revisionsnummer besitzt, wurde das \emph{Tagging} eingeführt. Mit Hilfe des \emph{Tagging} kann jeder Datei zu einem definierten Zeitpunkt ein einheitliches Tag vergeben werden. Zu einem Zeitpunkt X, besitzt bspw. \texttt{DateiA.txt} die Revision \emph{1.13} und \texttt{DateiB.txt} die Revision \emph{1.78}. Mit Hilfe eines Tag mit bspw. dem Namen \emph{Alpha 0.18} erhalten beide Dateien dieses zusätzliche Tag, auf das zu einer späteren Version zurückgegriffen werden kann. Das Tagging bietet in der Softwareentwicklung eine gute Möglichkeit wichtige Abschnitte des Quellcodes zu markieren, jedoch kann es vorkommen, dass diese Abschnitte separat weiterentwickelt werden müssen. Dies ist z.B. der Fall, wenn eine Software ausgeliefert wird, an dieser jedoch weiterentwickelt wird. Dabei ist es notwendig zwei getrennte  Entwicklungszweige fortzuführen. Einen Zweig um bei der ausgelieferten Version Fehler zu beheben und kleinere Folgeversionen zu veröffentlichen und einen Zweig um die Software weiter zuentwickeln. Diese Vorgehensweise wird als \emph{Branching} bezeichnet und hilft den Entwicklern bei der Entwicklung seinen Produktes auf unterschiedlichen Entwicklungszweigen. Der Hauptzweig eines Moduls wird als \emph{trunk}\footnote{engl. Stamm} bezeichnet und besitzt die Revision \emph{HEAD}. \emph{Merging} bezeichnet das Zusammenführen zweier Entwicklungszweige zu einem einzigen Zweig. Dies kann notwendig sein, um bspw. den Wartungszweig einer ausgelieferten Software mit dem Tag \emph{Version 1.0} mit dem Entwicklungszweig zur Version mit dem Tag \emph{Version 2.0} zusammen zuführen. Mit Hilfe verschiedener \emph{Trigger} können Skripte oder Programme im Repository ausgeführt werden. Die Trigger können vor und/oder nach dem Speichern der Dateien aufgeführt werden und dabei Einfluss auf das Speichern nehmen. So kann bspw. vor dem Speichern der Quellcode nach bekannten Bugs mit Hilfe verschiedener Programme\footnote{Checkstyle -- \url{http://checkstyle.sourceforge.net/} \\Findbugs -- \url{http://findbugs.sourceforge.net/}} gesucht werden. Im Fehlerfall wird der Quellcode nicht gespeichert und der Entwickler erhält eine Fehlermeldung. Nach dem Speichern der Dateien könnte ein weiteres Skript eine automatische Email an alle Projektmitglieder schicken und diese über die gespeicherten Änderungen informieren. CVS hat jedoch einige Nachteile: Zum einen können Dateien nicht umbenannt werden. Um den Dateinamen zu verändern, muss diese Datei aus dem Modul entfernt und mit dem neuen Namen hinzugefügt werden. Dabei beginnt jedoch die Revision von vorne zu zählen und somit kann auch nicht einfach auf die ältere Version zurückgegriffen werden. Zum anderen können auch Verzeichnisse nicht verschoben bzw. umbenannt werden. Um ein Verzeichniss zu verschieden, muss jede einzelne Datei in dem Verzeichnis aus dem Modul gelöscht und an neuer Stelle als neue Datei neu hinzugefügt werden. Diese Mißstände führten dazu, dass engachierte Softwareentwickler mit der Entwicklung einer neuer Versionsverwaltung mit dem Namen \emph{Subversion} begonnen haben.\citep{Wikipedia2005,Fogel2002,Price2005}

%====================================
\subsection{Subversion - SVN}
"`Subversion (SVN) ist eine Open-Source-Software zur Versionsverwaltung"', die oft als Nachfolger von CVS bezeichnet wird\citep{Wikipedia2005}. SVN ist ein von CVS unabhängigs Projekts und wird seit Anfang 2000 bei CoolabNet entwickelt. Seit dem 31.August 2001 ist Subversion "`self-hosting"', d.h. der Quellcode zu Subversion wird mit Subversion verwaltet. Am 23.Februar 2004 wurde die erste stabile Version 1.0 veröffentlicht. Bei der Entwicklung von Subversion wurde auf eine ähnliche Bedienung wie CVS geachtet, damit der Umstieg von CVS auf SVN für viele Entwickler einfach ist. Weiterhin unterstützt Subversion fast alle Funktionen von CVS, versucht jedoch dessen Nachteile zu vermeiden. In Subversion hat nicht jede Datei eine eigene Revison, sondern das gesamte Projekt eine einheitliche Versionsnummer, ähnlich einem Tag in CVS. Änderungen an einem Projekt werden meist an mehreren Dateien vorgenommen, die nun alle die gleiche Revision besitzen. Im Unterschied zu CVS benötigt Subversion neben der lokalen Arbeitskopie noch eine weitere zweite Kopie. Dadurch verdoppelt sich der benötigte Speicherbedarf bei dem Client, jedoch hat dies zum Vorteil, dass Subversion dadurch weniger Netzwerkzugriffe benötigt und bei einem \emph{commit} nur die Unterschiede zur Vorgängerversion überträgt und nicht wie CVS die kompletten Dateien. Weiterhin ist das umbenennen und verschieben von Dateien möglich, die Verwaltung von Verzeichnissen und Metadaten. Die \emph{commits} sind bei SVN atomar, d.h. Änderungen werden entweder komplett oder gar nicht ins Repository aufgenommen und Verbindungsabbrüche führen nicht zu inkonsistenten Zuständen. Der Zugriff auf den Subversionserver, der das Repository in einer Berkeley Datenbank oder seit Version 1.1 im Dateisystem speichert, kann über ein eigenen Protokoll, über die Secure shell oder über ein WebDav-Modul für den Apach2 Webserver erfolgen. \Vref{fig:svnarchitekur} verdeutlicht nochmal die gesamte Subversion Architektur. Dabei ist zu sehen, dass über Kommandozeilenparameter oder einer grafischen Oberfläche auf die Client-Bibliothek zugegriffen werden kann. Diese Bibliothek kann über verschiedene Methoden auf das SVN Repository zugreifen. Dabei gibt es die direkte lokal Zugriffsart oder der Zugriff über ein Netzwerk/Internet. Das Repository speichert die Dateien bzw. die Unterschiede der Dateien letztendlich in einer Berkeley Datenbank oder auf dem Dateisystem. Subversion bietet somit fast die gleiche Funktionalität die CVS, behebt dessen Nachteile und bietet dazu noch einige Extrafunktionen. \citep{Wikipedia2005,Collins-Sussman2005}
\begin{figure}[tbp]
	\centering
	\includegraphics[scale=0.65]{images/subversion-architektur.png}
	\caption{Subversion's Architektur \citep[Kap.~1]{Collins-Sussman2005}}
	\label{fig:svnarchitekur}
\end{figure}







%Hier danach nicht mehr schreiben
\label{sec:tech-Versionsverwaltung-ende}